// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

use std::fs;
use std::path::Path;

mod doc;
mod validation;

use validation::{ControlLineType, RomType, RomTypesConfig};

pub const ROM_TYPES_JSON_FILENAME: &str = "json/rom-types.json";
pub const ROM_GENERATED_RS_FILENAME: &str = "rom/generated.rs";
pub const ROM_MOD_RS_FILENAME: &str = "rom/mod.rs";
pub const ROM_DOCS_MD_FILENAME: &str = "ROM-TYPES.md";

pub fn build(manifest_path: &Path) {
    // Construct path to JSON config
    let json_path = manifest_path.join(ROM_TYPES_JSON_FILENAME);

    // Tell Cargo to rerun only if the JSON config changes
    println!("cargo:rerun-if-changed={}", json_path.display());

    // Read and validate the configuration
    let json = fs::read_to_string(&json_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", json_path.display(), e));

    let config = RomTypesConfig::from_json(&json)
        .unwrap_or_else(|e| panic!("Failed to parse or validate {}: {}", json_path.display(), e));

    // Generate Rust code for types and implementations
    let generated_code = generate_rust_code(&config);

    // Generate lib.rs with documentation
    let lib_code = generate_lib_rs(&config);

    // Generate markdown docs
    let markdown = doc::generate_rom_types_markdown(&config);

    // Write src/rom/generated.rs
    let src_path = manifest_path.join("src").join(ROM_GENERATED_RS_FILENAME);
    fs::write(&src_path, &generated_code)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", src_path.display(), e));

    // Write src/rom/mod.rs
    let mod_path = manifest_path.join("src").join(ROM_MOD_RS_FILENAME);
    fs::write(&mod_path, &lib_code)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", mod_path.display(), e));

    // Write docs/rom-types.md
    let docs_path = manifest_path
        .join("..")
        .join("..")
        .join("docs")
        .join(ROM_DOCS_MD_FILENAME);
    fs::create_dir_all(docs_path.parent().unwrap())
        .unwrap_or_else(|e| panic!("Failed to create docs directory: {}", e));
    fs::write(&docs_path, &markdown)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", docs_path.display(), e));

    eprintln!("Documentation generated at {}", docs_path.display());
}

fn get_sorted_rom_types<'a>(config: &'a RomTypesConfig) -> Vec<(&'a String, &'a RomType)> {
    let mut types: Vec<_> = config.rom_types.iter().collect();
    // Sort by: pin count, then size, then name (for determinism)
    types.sort_by_key(|(name, rom_type)| (rom_type.pins, rom_type.size, *name));
    types
}

fn generate_lib_rs(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("// AUTO-GENERATED by build/main.rs - DO NOT EDIT MANUALLY\n");
    code.push_str("// Generated from hw-config/rom-types.json\n");
    code.push_str("//\n");
    code.push_str("// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>\n");
    code.push_str("// MIT License\n\n");

    code.push_str("//! ROM type configurations for One ROM\n");
    code.push_str("//!\n");
    code.push_str(
        "//! This module provides compile-time ROM chip specifications for retro computing\n",
    );
    code.push_str("//! systems. All data is generated at build time from JSON configuration and\n");
    code.push_str("//! embedded as const data - no runtime parsing or allocations needed.\n");
    code.push_str("//!\n");
    code.push_str(
        "//! It is primarily intended for use by the One ROM firmware tooling, but may be\n",
    );
    code.push_str("//! useful in other embedded or WASM projects related to One ROM, such as\n");
    code.push_str("//! Airfrog.\n");
    code.push_str("//!\n");
    code.push_str(
        "//! Note that the presence of ROM types in this crate does not imply that they are\n",
    );
    code.push_str(
        "//! supported by all (or even any!) One ROM hardware versions. Please check the\n",
    );
    code.push_str("//! One ROM documentation for supported ROM types.\n");
    code.push_str("//!\n");
    code.push_str("//! # Supported ROM Types\n");
    code.push_str("//!\n");

    // Group ROMs by type for documentation
    let mut mask_24pin = Vec::new();
    let mut mask_28pin = Vec::new();
    let mut eprom_24pin = Vec::new();
    let mut eprom_28pin = Vec::new();

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            let entry = format!(
                "//! - **{}**: {} ({})\n",
                type_name,
                rom_type
                    .description
                    .split(" with ")
                    .next()
                    .unwrap_or(&rom_type.description),
                rom_type
                    .description
                    .split(" with ")
                    .nth(1)
                    .unwrap_or("see datasheet")
            );

            if type_name.starts_with("23") {
                if rom_type.pins == 24 {
                    mask_24pin.push(entry);
                } else {
                    mask_28pin.push(entry);
                }
            } else if type_name.starts_with("27") {
                if rom_type.pins == 24 {
                    eprom_24pin.push(entry);
                } else {
                    eprom_28pin.push(entry);
                }
            }
        }
    }

    if !mask_24pin.is_empty() {
        code.push_str("//! ## 24-pin Mask ROMs (23xx series)\n");
        for entry in mask_24pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !mask_28pin.is_empty() {
        code.push_str("//! ## 28-pin Mask ROMs (23xx series)\n");
        for entry in mask_28pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !eprom_24pin.is_empty() {
        code.push_str("//! ## 24-pin EPROMs (27xx series)\n");
        for entry in eprom_24pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    if !eprom_28pin.is_empty() {
        code.push_str("//! ## 28-pin EPROMs (27xx series)\n");
        for entry in eprom_28pin {
            code.push_str(&entry);
        }
        code.push_str("//!\n");
    }

    code.push_str("//! # Usage\n");
    code.push_str("//!\n");
    code.push_str("//! ```\n");
    code.push_str("//! use onerom_config::rom::{RomType, ControlLineType};\n");
    code.push_str("//!\n");
    code.push_str("//! // Get ROM specifications\n");
    code.push_str("//! let rom = RomType::Rom2364;\n");
    code.push_str("//! assert_eq!(rom.size_bytes(), 8192);\n");
    code.push_str("//! assert_eq!(rom.rom_pins(), 24);\n");
    code.push_str("//! assert_eq!(rom.num_addr_lines(), 13);\n");
    code.push_str("//!\n");
    code.push_str("//! // Get pin mappings\n");
    code.push_str("//! let addr_pins = rom.address_pins();\n");
    code.push_str("//! let data_pins = rom.data_pins();\n");
    code.push_str("//! println!(\"A0 is on pin {}\", addr_pins[0]);\n");
    code.push_str("//! println!(\"D0 is on pin {}\", data_pins[0]);\n");
    code.push_str("//!\n");
    code.push_str("//! // Check control lines\n");
    code.push_str("//! let control = rom.control_lines();\n");
    code.push_str("//! assert_eq!(control.len(), 1);\n");
    code.push_str("//! assert_eq!(control[0].name, \"cs1\");\n");
    code.push_str("//! assert_eq!(control[0].line_type, ControlLineType::Configurable);\n");
    code.push_str("//!\n");
    code.push_str("//! // Parse from string\n");
    code.push_str("//! if let Some(rom) = RomType::try_from_str(\"27128\") {\n");
    code.push_str("//!     println!(\"Found ROM: {}\", rom.name());\n");
    code.push_str("//! }\n");
    code.push_str("//! ```\n");
    code.push_str("//!\n");
    code.push_str("//! # Features\n");
    code.push_str("//!\n");
    code.push_str("//! - **Zero runtime cost**: All data is const, compiled into your binary\n");
    code.push_str("//! - **no_std and no allocations**: Perfect for embedded systems and WASM\n");
    code.push_str("//! - **Type safe**: Enum-based API prevents invalid ROM type references\n");
    code.push_str("//! - **Validated**: Build fails if JSON config is invalid\n");
    code.push_str("//!\n");
    code.push_str("//! # Architecture\n");
    code.push_str("//!\n");
    code.push_str("//! This crate uses the build/main.rs script to:\n");
    code.push_str("//! 1. Read `hw-config/rom-types.json` from the repository root\n");
    code.push_str("//! 2. Validate all ROM specifications at build time\n");
    code.push_str("//! 3. Generate Rust const data structures\n");
    code.push_str("//! 4. Fail the build if validation errors occur\n");
    code.push_str("//!\n");
    code.push_str("//! The generated code is pure Rust with no dependencies, making it suitable\n");
    code.push_str("//! for use in no_std environments, WASM, and any Rust project.\n\n");

    code.push_str("#![deny(missing_docs)]\n");
    code.push_str("#![deny(unsafe_code)]\n\n");

    code.push_str("mod generated;\n\n");
    code.push_str("pub use generated::*;\n");

    code
}

fn generate_rust_code(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    // File header
    code.push_str("// AUTO-GENERATED by build/main.rs - DO NOT EDIT MANUALLY\n");
    code.push_str("// Generated from hw-config/rom-types.json\n");
    code.push_str("\n");
    code.push_str("// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>\n");
    code.push_str("//\n");
    code.push_str("// MIT License\n\n");
    code.push_str("#![allow(dead_code)]\n\n");

    // Generate control line type enum
    code.push_str(generate_control_line_type_enum());
    code.push_str("\n\n");

    // Generate control line spec struct
    code.push_str(generate_control_line_spec_struct());
    code.push_str("\n\n");

    // Generate programming pin spec struct
    code.push_str(generate_programming_pin_spec_struct());
    code.push_str("\n\n");

    // Generate power pin spec struct
    code.push_str(generate_power_pin_spec_struct());
    code.push_str("\n\n");

    // Generate RomType enum
    code.push_str(&generate_rom_type_enum(config));
    code.push_str("\n\n");

    // Generate RomType implementation
    code.push_str(&generate_rom_type_impl(config));

    code
}

fn generate_control_line_type_enum() -> &'static str {
    r#"/// Control line behavior type
///
/// Defines whether a control line is user-configurable (mask-programmable)
/// or fixed active-low per JEDEC standard.
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum ControlLineType {
    /// CS line with user-configurable polarity (23xxx series mask ROMs)
    ///
    /// These lines can be mask-programmed as either active-high or active-low
    /// during manufacturing. The user must specify the polarity in their configuration.
    Configurable,
    
    /// Fixed active-low control line (27xxx series EPROMs)
    ///
    /// These lines follow the JEDEC standard and are always active-low (/CE, /OE).
    FixedActiveLow,
}"#
}

fn generate_control_line_spec_struct() -> &'static str {
    r#"/// Specification for a single control line
///
/// Defines the physical pin number and behavior type for control signals
/// like chip select (CS), chip enable (CE), and output enable (OE).
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub struct ControlLineSpec {
    /// Signal name (e.g., "cs1", "ce", "oe")
    pub name: &'static str,
    
    /// Physical pin number on the ROM package
    pub pin: u8,
    
    /// Behavior type (configurable or fixed active-low)
    pub line_type: ControlLineType,
}"#
}

fn generate_programming_pin_spec_struct() -> &'static str {
    r#"/// Programming pin read state specification
///
/// Defines the required state for programming-related pins (Vpp, /PGM)
/// during normal read operations.
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum ProgrammingPinState {
    /// Pin must be at Vcc (5V)
    Vcc,
    
    /// Pin must be logic high
    High,
    
    /// Pin must be logic low  
    Low,
    
    /// Pin generates chip select (output enable) signal
    ///
    /// Used for shared /OE/VPP pins (e.g., 2732 pin 20) where the pin
    /// serves as output enable during read and VPP during programming.
    ChipSelect,
}

/// Programming pin specification
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub struct ProgrammingPinSpec {
    /// Pin name (e.g., "vpp", "pgm", "oe_vpp")
    pub name: &'static str,
    
    /// Physical pin number on the ROM package
    pub pin: u8,
    
    /// Required state during read operations
    pub read_state: ProgrammingPinState,
}"#
}

fn generate_power_pin_spec_struct() -> &'static str {
    r#"/// Power pin specification
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub struct PowerPinSpec {
    /// Pin name ("vcc" or "gnd")
    pub name: &'static str,
    
    /// Physical pin number on the ROM package
    pub pin: u8,
}"#
}

fn generate_rom_type_enum(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("/// ROM chip type\n");
    code.push_str("///\n");
    code.push_str("/// Supported retro ROM chip types with their pinouts and characteristics.\n");
    code.push_str("/// Includes mask ROMs (23xx series) and EPROMs (27xx series).\n");
    code.push_str("///\n");
    code.push_str("/// # Examples\n");
    code.push_str("///\n");
    code.push_str("/// ```\n");
    code.push_str("/// use onerom_config::rom::RomType;\n");
    code.push_str("///\n");
    code.push_str("/// let rom = RomType::Rom2364;\n");
    code.push_str("/// assert_eq!(rom.size_bytes(), 8192);\n");
    code.push_str("/// assert_eq!(rom.rom_pins(), 24);\n");
    code.push_str("/// assert_eq!(rom.num_addr_lines(), 13);\n");
    code.push_str("/// ```\n");
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize)]\n");
    code.push_str("#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n");
    code.push_str("pub enum RomType {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name.as_str()) {
            code.push_str(&format!(
                "    /// {} - {} bytes, {}-pin package\n",
                rom_type.description, rom_type.size, rom_type.pins
            ));
            code.push_str(&format!("    #[cfg_attr(feature = \"schemars\", schemars(rename = \"{type_name}\"))]\n"));
            code.push_str(&format!("    Rom{},\n", type_name));
        }
    }

    code.push_str("}\n\n");

    code.push_str("impl<'de> serde::Deserialize<'de> for RomType {\n");
    code.push_str("    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n");
    code.push_str("    where\n");
    code.push_str("        D: serde::Deserializer<'de>,\n");
    code.push_str("    {\n");
    code.push_str("        let s = <&str>::deserialize(deserializer)?;\n");
    code.push_str("        match s {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if config.rom_types.get(type_name.as_str()).is_some() {
            code.push_str(&format!(
                "            \"Rom{}\" | \"{}\" => Ok(RomType::Rom{}),\n",
                type_name, type_name, type_name
            ));
        }
    }

    code.push_str("            _ => Err(serde::de::Error::unknown_variant(\n");
    code.push_str("                &s,\n");
    code.push_str("                &[");

    let type_names: Vec<String> = get_sorted_rom_types(config)
        .iter()
        .filter_map(|(type_name, _)| {
            if config.rom_types.get(type_name.as_str()).is_some() {
                Some(format!("\"{}\"", type_name))
            } else {
                None
            }
        })
        .collect();
    code.push_str(&type_names.join(", "));

    code.push_str("],\n");
    code.push_str("            )),\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    code.push_str("/// All supported ROM types\n");
    code.push_str("pub const ROM_TYPES: &[RomType] = &[\n");
    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if config.rom_types.get(type_name.as_str()).is_some() {
            code.push_str(&format!("    RomType::Rom{},\n", type_name));
        }
    }
    code.push_str("];\n");

    code
}

fn generate_rom_type_impl(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("impl RomType {\n");

    // Generate try_from_str
    code.push_str(&generate_try_from_str(config));
    code.push_str("\n\n");

    // Generate name
    code.push_str(&generate_name_method(config));
    code.push_str("\n\n");

    // Generate c_enum_name
    code.push_str(&generate_c_enum_method(config));
    code.push_str("\n\n");

    // Generate rom_pins
    code.push_str(&generate_rom_pins_method(config));
    code.push_str("\n\n");

    // Generate size_bytes
    code.push_str(&generate_size_bytes_method(config));
    code.push_str("\n\n");

    // Generate num_addr_lines
    code.push_str(&generate_num_addr_lines_method(config));
    code.push_str("\n\n");

    // Generate address_pins
    code.push_str(&generate_address_pins_method(config));
    code.push_str("\n\n");

    // Generate data_pins
    code.push_str(&generate_data_pins_method(config));
    code.push_str("\n\n");

    // Generate control_lines
    code.push_str(&generate_control_lines_method(config));
    code.push_str("\n\n");

    // Generate programming_pins
    code.push_str(&generate_programming_pins_method(config));
    code.push_str("\n\n");

    // Generate power_pins
    code.push_str(&generate_power_pins_method(config));
    code.push_str("\n\n");

    code.push_str("}\n");
    code
}

fn generate_try_from_str(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Parse ROM type from string identifier\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(RomType::try_from_str(\"2364\"), Some(RomType::Rom2364));\n");
    code.push_str(
        "    /// assert_eq!(RomType::try_from_str(\"27128\"), Some(RomType::Rom27128));\n",
    );
    code.push_str("    /// assert_eq!(RomType::try_from_str(\"invalid\"), None);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub fn try_from_str(s: &str) -> Option<Self> {\n");
    code.push_str("        match s {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if config.rom_types.contains_key(type_name) {
            code.push_str(&format!(
                "            \"{}\" => Some(RomType::Rom{}),\n",
                type_name, type_name
            ));
        }
    }

    code.push_str("            _ => None,\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_name_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get the ROM type name as a string\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(RomType::Rom2364.name(), \"2364\");\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn name(&self) -> &'static str {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if config.rom_types.contains_key(type_name) {
            code.push_str(&format!(
                "            RomType::Rom{} => \"{}\",\n",
                type_name, type_name
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_c_enum_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get the C enum name for this ROM type\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(RomType::Rom2364.c_enum_name(), \"ROM_TYPE_2364\");\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn c_enum_name(&self) -> &'static str {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if config.rom_types.contains_key(type_name) {
            code.push_str(&format!(
                "            RomType::Rom{} => \"ROM_TYPE_{}\",\n",
                type_name, type_name
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_rom_pins_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get the number of pins in the ROM package\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(RomType::Rom2364.rom_pins(), 24);\n");
    code.push_str("    /// assert_eq!(RomType::Rom27128.rom_pins(), 28);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn rom_pins(&self) -> u8 {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            code.push_str(&format!(
                "            RomType::Rom{} => {},\n",
                type_name, rom_type.pins
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_size_bytes_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get ROM capacity in bytes\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(RomType::Rom2316.size_bytes(), 2048);\n");
    code.push_str("    /// assert_eq!(RomType::Rom27512.size_bytes(), 65536);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn size_bytes(&self) -> usize {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            code.push_str(&format!(
                "            RomType::Rom{} => {},\n",
                type_name, rom_type.size
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_num_addr_lines_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get number of address lines\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// assert_eq!(RomType::Rom2364.num_addr_lines(), 13); // 2^13 = 8192\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn num_addr_lines(&self) -> usize {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            code.push_str(&format!(
                "            RomType::Rom{} => {},\n",
                type_name,
                rom_type.address.len()
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_address_pins_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get address line pin mapping\n");
    code.push_str("    ///\n");
    code.push_str(
        "    /// Returns an array where index is the logical address line number (A0, A1, ...)\n",
    );
    code.push_str("    /// and the value is the physical pin number on the ROM package.\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// let pins = RomType::Rom2364.address_pins();\n");
    code.push_str("    /// assert_eq!(pins[0], 8);  // A0 is on pin 8\n");
    code.push_str("    /// assert_eq!(pins[12], 21); // A12 is on pin 21\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn address_pins(&self) -> &'static [u8] {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            let pins_str = rom_type
                .address
                .iter()
                .map(|p| p.to_string())
                .collect::<Vec<_>>()
                .join(", ");
            code.push_str(&format!(
                "            RomType::Rom{} => &[{}],\n",
                type_name, pins_str
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_data_pins_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get data line pin mapping\n");
    code.push_str("    ///\n");
    code.push_str("    /// Returns an array where index is the logical data line number (D0-D7)\n");
    code.push_str("    /// and the value is the physical pin number on the ROM package.\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// let pins = RomType::Rom2364.data_pins();\n");
    code.push_str("    /// assert_eq!(pins.len(), 8);\n");
    code.push_str("    /// assert_eq!(pins[0], 9);  // D0 is on pin 9\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn data_pins(&self) -> &'static [u8] {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            let pins_str = rom_type
                .data
                .iter()
                .map(|p| p.to_string())
                .collect::<Vec<_>>()
                .join(", ");
            code.push_str(&format!(
                "            RomType::Rom{} => &[{}],\n",
                type_name, pins_str
            ));
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_control_lines_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get control line specifications\n");
    code.push_str("    ///\n");
    code.push_str("    /// Returns control line specs for CS (chip select), CE (chip enable),\n");
    code.push_str("    /// and OE (output enable) signals.\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::{RomType, ControlLineType};\n");
    code.push_str("    ///\n");
    code.push_str("    /// let lines = RomType::Rom2364.control_lines();\n");
    code.push_str("    /// assert_eq!(lines.len(), 1);\n");
    code.push_str("    /// assert_eq!(lines[0].name, \"cs1\");\n");
    code.push_str("    /// assert_eq!(lines[0].line_type, ControlLineType::Configurable);\n");
    code.push_str("    ///\n");
    code.push_str("    /// let lines = RomType::Rom27128.control_lines();\n");
    code.push_str("    /// assert_eq!(lines.len(), 2);\n");
    code.push_str("    /// assert!(lines.iter().any(|l| l.name == \"ce\"));\n");
    code.push_str("    /// assert!(lines.iter().any(|l| l.name == \"oe\"));\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn control_lines(&self) -> &'static [ControlLineSpec] {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            // Generate const array for this ROM type
            code.push_str(&format!("            RomType::Rom{} => &[\n", type_name));

            // Sort control lines by name for consistency
            let mut control_lines: Vec<_> = rom_type.control.iter().collect();
            control_lines.sort_by_key(|(name, _)| *name);

            for (name, control) in control_lines {
                let line_type = match control.line_type {
                    ControlLineType::Configurable => "ControlLineType::Configurable",
                    ControlLineType::FixedActiveLow => "ControlLineType::FixedActiveLow",
                };
                code.push_str(&format!(
                    "                ControlLineSpec {{ name: \"{}\", pin: {}, line_type: {} }},\n",
                    name, control.pin, line_type
                ));
            }

            code.push_str("            ],\n");
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_programming_pins_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get programming pin specifications\n");
    code.push_str("    ///\n");
    code.push_str(
        "    /// Returns specifications for programming-related pins (Vpp, /PGM) and their\n",
    );
    code.push_str(
        "    /// required states during normal read operations. Returns None if the ROM type\n",
    );
    code.push_str("    /// has no programming pins (e.g., 27512 where pin 1 is A15).\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::{RomType, ProgrammingPinState};\n");
    code.push_str("    ///\n");
    code.push_str("    /// let pins = RomType::Rom27128.programming_pins().unwrap();\n");
    code.push_str("    /// assert_eq!(pins.len(), 2);\n");
    code.push_str("    /// let vpp = pins.iter().find(|p| p.name == \"vpp\").unwrap();\n");
    code.push_str("    /// assert_eq!(vpp.read_state, ProgrammingPinState::Vcc);\n");
    code.push_str("    /// ```\n");
    code.push_str(
        "    pub const fn programming_pins(&self) -> Option<&'static [ProgrammingPinSpec]> {\n",
    );
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            if let Some(ref prog) = rom_type.programming {
                let mut specs = Vec::new();

                if let Some(ref vpp) = prog.vpp {
                    let state = match vpp.read_state.as_str() {
                        "vcc" => "ProgrammingPinState::Vcc",
                        "high" => "ProgrammingPinState::High",
                        "low" => "ProgrammingPinState::Low",
                        "chip_select" => "ProgrammingPinState::ChipSelect",
                        _ => panic!("Invalid read state"),
                    };
                    specs.push(format!(
                        "ProgrammingPinSpec {{ name: \"vpp\", pin: {}, read_state: {} }}",
                        vpp.pin, state
                    ));
                }

                if let Some(ref pgm) = prog.pgm {
                    let state = match pgm.read_state.as_str() {
                        "vcc" => "ProgrammingPinState::Vcc",
                        "high" => "ProgrammingPinState::High",
                        "low" => "ProgrammingPinState::Low",
                        "chip_select" => "ProgrammingPinState::ChipSelect",
                        _ => panic!("Invalid read state"),
                    };
                    specs.push(format!(
                        "ProgrammingPinSpec {{ name: \"pgm\", pin: {}, read_state: {} }}",
                        pgm.pin, state
                    ));
                }

                if !specs.is_empty() {
                    code.push_str(&format!(
                        "            RomType::Rom{} => Some(&[\n",
                        type_name
                    ));
                    for spec in specs {
                        code.push_str(&format!("                {},\n", spec));
                    }
                    code.push_str("            ]),\n");
                } else {
                    code.push_str(&format!("            RomType::Rom{} => None,\n", type_name));
                }
            } else {
                code.push_str(&format!("            RomType::Rom{} => None,\n", type_name));
            }
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}

fn generate_power_pins_method(config: &RomTypesConfig) -> String {
    let mut code = String::new();

    code.push_str("    /// Get power pin specifications\n");
    code.push_str("    ///\n");
    code.push_str("    /// Returns VCC and GND pin locations for the ROM package.\n");
    code.push_str("    ///\n");
    code.push_str("    /// # Examples\n");
    code.push_str("    ///\n");
    code.push_str("    /// ```\n");
    code.push_str("    /// use onerom_config::rom::RomType;\n");
    code.push_str("    ///\n");
    code.push_str("    /// let pins = RomType::Rom2364.power_pins();\n");
    code.push_str("    /// assert_eq!(pins.len(), 2);\n");
    code.push_str("    /// ```\n");
    code.push_str("    pub const fn power_pins(&self) -> &'static [PowerPinSpec] {\n");
    code.push_str("        match self {\n");

    for (type_name, _rom_type) in get_sorted_rom_types(config) {
        if let Some(rom_type) = config.rom_types.get(type_name) {
            let (gnd_pin, vcc_pin) = if rom_type.pins == 24 {
                (12, 24)
            } else {
                (14, 28)
            };
            
            code.push_str(&format!(
                "            RomType::Rom{} => &[\n",
                type_name
            ));
            code.push_str(&format!(
                "                PowerPinSpec {{ name: \"gnd\", pin: {} }},\n",
                gnd_pin
            ));
            code.push_str(&format!(
                "                PowerPinSpec {{ name: \"vcc\", pin: {} }},\n",
                vcc_pin
            ));
            code.push_str("            ],\n");
        }
    }

    code.push_str("        }\n");
    code.push_str("    }\n");
    code
}
