// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

//! sdrr-gen - Generates the firmware files required by SDRR.

use anyhow::{Context, Result};
use std::fs;
use std::io::Write;
use std::path::Path;
use strum::IntoEnumIterator;

use onerom_config::mcu::Family as McuFamily;
use onerom_config::rom::RomType;

use onerom_gen::image::{CsLogic, RomSet, RomSetType};

use crate::config::Config;
use crate::file::{OutType, out_filename};
use crate::fw::PllConfig;

// Generate all output files
pub fn generate_files(config: &Config, rom_sets: &[RomSet]) -> Result<()> {
    // Create output directory if it doesn't exist
    if !config.output_dir.exists() {
        fs::create_dir_all(&config.output_dir).with_context(|| {
            format!(
                "Failed to create output directory: {}",
                config.output_dir.display()
            )
        })?;
    }

    // Generate all of the output files
    for out_type in OutType::iter() {
        let filename = out_filename(out_type);
        match out_type {
            OutType::RomsC => generate_roms_implementation_file(&filename, config, rom_sets)?,
            OutType::RomsH => generate_roms_header_file(&filename, config, rom_sets)?,
            OutType::SdrrConfigH => generate_sdrr_config_header(&filename, config)?,
            OutType::SdrrConfigC => generate_sdrr_config_implementation(&filename, config)?,
            OutType::GenMk => generate_makefile_fragment(&filename, config)?,
            OutType::LinkerLd => generate_linker_script(&filename, config)?,
            OutType::PlatformBootBlockLd => generate_platform_ld_script(&filename, config)?,
        }
    }
    Ok(())
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FileType {
    C,
    Makefile,
    Linker,
}

fn create_file(output_dir: &Path, filename: &Path, filetype: FileType) -> Result<fs::File> {
    let file_path = output_dir.join(filename);
    let mut file = fs::File::create(&file_path)
        .with_context(|| format!("Failed to create file: {}", file_path.display()))?;

    write_header(filename, &mut file, filetype)?;

    Ok(file)
}

fn write_header(name: &Path, file: &mut fs::File, filetype: FileType) -> Result<()> {
    let comment = match filetype {
        FileType::C => "//",
        FileType::Makefile => "#",
        FileType::Linker => "",
    };
    if filetype == FileType::Linker {
        writeln!(file, "/*")?;
    }
    writeln!(file, "{comment} {}", name.display())?;
    writeln!(file)?;
    writeln!(
        file,
        "{comment} This file was auto-generated by sdrr-gen using the following arguments:"
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment}   {}",
        std::env::args().skip(1).collect::<Vec<_>>().join(" ")
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment} Do not edit this file directly - instead rengerate using sdrr-gen."
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment} This is most easily done by modifying the configuration at the beginning"
    )?;
    writeln!(
        file,
        "{comment} of the Makefile in the repostiory root and running `make` from there."
    )?;
    if filetype == FileType::Linker {
        writeln!(file, "*/")?;
    }
    writeln!(file)?;

    Ok(())
}

// Generate roms.h header file
fn generate_roms_header_file(filename: &Path, config: &Config, rom_sets: &[RomSet]) -> Result<()> {
    let mut file = create_file(&config.output_dir, filename, FileType::C)?;

    writeln!(file, "#ifndef SDRR_ROMS_H")?;
    writeln!(file, "#define SDRR_ROMS_H")?;
    writeln!(file)?;
    writeln!(file, "#include <stdint.h>")?;
    writeln!(file)?;
    writeln!(file, "// Number of ROM images and sets")?;
    writeln!(file, "#define SDRR_NUM_IMAGES  {}", config.roms.len())?;
    writeln!(file, "#define SDRR_NUM_SETS    {}", rom_sets.len())?;
    writeln!(file)?;

    // ROM set array
    writeln!(file, "// ROM set array")?;
    writeln!(file, "extern const uint8_t sdrr_rom_set_count;")?;
    if !rom_sets.is_empty() {
        writeln!(file, "extern const sdrr_rom_set_t rom_set[SDRR_NUM_SETS];")?;
    }
    writeln!(file)?;

    writeln!(file, "#endif // SDRR_ROMS_H")?;

    Ok(())
}

// Generate roms.c implementation file
fn generate_roms_implementation_file(
    filename: &Path,
    config: &Config,
    rom_sets: &[RomSet],
) -> Result<()> {
    let mut file = create_file(&config.output_dir, filename, FileType::C)?;

    writeln!(file, "#include \"sdrr_config.h\"")?;
    writeln!(file, "#include \"config_base.h\"")?;
    writeln!(file, "#include \"roms.h\"")?;
    writeln!(file)?;

    // Generate metadata header (goes first in metadata section via linker)
    writeln!(file, "//")?;
    writeln!(file, "// Metadata header")?;
    writeln!(file, "//")?;
    if !rom_sets.is_empty() {
        writeln!(file, "// Forward declaration of rom_set array")?;
        writeln!(file, "extern const sdrr_rom_set_t rom_set[SDRR_NUM_SETS];")?;
        writeln!(file)?;
    }
    writeln!(file, "__attribute__((section(\".metadata.header\")))")?;
    writeln!(
        file,
        "const onerom_metadata_header_t onerom_metadata_header = {{"
    )?;
    writeln!(file, "    .magic = \"ONEROM_METADATA\",")?;
    writeln!(file, "    .version = 1,")?;
    writeln!(file, "    .rom_set_count = SDRR_NUM_SETS,")?;
    writeln!(file, "    .pad1 = {{0, 0, 0}},")?;
    if rom_sets.is_empty() {
        writeln!(file, "    .rom_sets = (void *)0,")?;
    } else {
        writeln!(file, "    .rom_sets = rom_set,")?;
    }
    writeln!(file, "    .reserved = {{")?;
    for _ in 0..28 {
        writeln!(
            file,
            "        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,"
        )?;
    }
    writeln!(file, "        0xff, 0xff, 0xff, 0xff,")?; // Last 4 bytes to make 228 total
    writeln!(file, "    }},")?;
    writeln!(file, "}};")?;
    writeln!(file)?;

    // Generate filename strings (debug only)
    writeln!(file, "// ROM filenames")?;
    for set in rom_sets {
        for rom in &set.roms {
            let filename = rom.filename();
            let index = rom.index();
            writeln!(file, "__attribute__((section(\".metadata.data\")))")?;
            writeln!(
                file,
                "static const char sdrr_rom_{index}_filename[] = \"{filename}\";",
            )?;
        }
    }
    writeln!(file)?;

    // Helper function to convert CsLogic to enum string
    let cs_logic_to_enum = |cs_logic: CsLogic| -> &'static str {
        match cs_logic {
            CsLogic::ActiveLow => "CS_ACTIVE_LOW",
            CsLogic::ActiveHigh => "CS_ACTIVE_HIGH",
            CsLogic::Ignore => "CS_NOT_USED",
        }
    };

    writeln!(
        file,
        "// All objects are static, except for the rom_set array.  This is the only"
    )?;
    writeln!(
        file,
        "// object which should be directly accessed by the rest of the code."
    )?;
    writeln!(file)?;

    // Generate ROM information array
    writeln!(file, "//")?;
    writeln!(file, "// ROM info")?;
    writeln!(file, "//")?;
    writeln!(file)?;

    for (ii, rom_config) in config.roms.iter().enumerate() {
        writeln!(file, "// ROM {}", ii)?;

        writeln!(file, "__attribute__((section(\".metadata.data\")))")?;
        writeln!(file, "static const sdrr_rom_info_t rom_{}_info = {{", ii)?;

        let cs1_state = cs_logic_to_enum(rom_config.cs_config.cs1_logic());
        let cs2_state = rom_config
            .cs_config
            .cs2_logic()
            .map(cs_logic_to_enum)
            .unwrap_or("CS_NOT_USED");
        let cs3_state = rom_config
            .cs_config
            .cs3_logic()
            .map(cs_logic_to_enum)
            .unwrap_or("CS_NOT_USED");

        writeln!(
            file,
            "    .rom_type = {},",
            rom_config.rom_type.c_enum_name()
        )?;
        writeln!(file, "    .cs1_state = {},", cs1_state)?;
        writeln!(file, "    .cs2_state = {},", cs2_state)?;
        writeln!(file, "    .cs3_state = {},", cs3_state)?;
        writeln!(file, "    .filename = sdrr_rom_{}_filename,", ii)?;
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    // Add array of pointers for each ROM set, where there is a 1:1 mapping
    // between the ROMs and rom sets
    writeln!(file, "//")?;
    writeln!(file, "// ROM set definitions")?;
    writeln!(file, "//")?;
    writeln!(file)?;

    for rom_set in rom_sets {
        let ii = rom_set.id;
        writeln!(file, "// ROM set {}", ii)?;
        let num_roms = rom_set.roms.len();
        writeln!(file, "#define ROM_SET_{}_ROM_COUNT  {}", ii, num_roms)?;
        if num_roms == 1 {
            match config.mcu_variant.family() {
                McuFamily::Rp2350 => writeln!(
                    file,
                    "#define ROM_SET_{}_DATA_SIZE  ROM_IMAGE_SIZE_RP235X",
                    ii
                )?,
                McuFamily::Stm32f4 => writeln!(
                    file,
                    "#define ROM_SET_{}_DATA_SIZE  ROM_IMAGE_SIZE_STM32F4",
                    ii
                )?,
            }
        } else {
            writeln!(file, "#define ROM_SET_{}_DATA_SIZE  ROM_SET_IMAGE_SIZE", ii)?;
        }
        writeln!(
            file,
            "static const uint8_t rom_set_{}_data[];  // Forward declaration",
            ii
        )?;
        writeln!(file, "__attribute__((section(\".metadata.data\")))")?;
        writeln!(
            file,
            "static const sdrr_rom_info_t * const rom_set_{}_roms[] = {{",
            ii
        )?;
        for rom_in_set in &rom_set.roms {
            writeln!(file, "    &rom_{}_info,", rom_in_set.index())?;
        }
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    // Create the ROM sets
    writeln!(file, "//")?;
    writeln!(file, "// ROM set array")?;
    writeln!(file, "//")?;
    writeln!(file, "__attribute__((section(\".metadata.data\")))")?;
    writeln!(file, "const uint8_t sdrr_rom_set_count = SDRR_NUM_SETS;")?;
    writeln!(file, "__attribute__((section(\".metadata.data\")))")?;
    writeln!(file, "const sdrr_rom_set_t rom_set[SDRR_NUM_SETS] = {{")?;

    for rom_set in rom_sets {
        let ii = rom_set.id;
        let num_roms = rom_set.roms.len();
        let serve_alg = if num_roms == 1 || rom_set.set_type == RomSetType::Banked {
            config.serve_alg.c_value()
        } else {
            config.serve_alg.c_value_multi_rom_set()
        };
        writeln!(file, "    {{")?;
        writeln!(file, "        .data = rom_set_{}_data,", ii)?;
        writeln!(file, "        .size = ROM_SET_{}_DATA_SIZE,", ii)?;
        writeln!(file, "        .roms = rom_set_{}_roms,", ii)?;
        writeln!(file, "        .rom_count = ROM_SET_{}_ROM_COUNT,", ii)?;
        writeln!(file, "        .serve = {},", serve_alg)?;
        let multi_cs_logic = rom_set
            .multi_cs_logic()
            .map_err(|e| anyhow::anyhow!("In ROM set {}: {e:?}", rom_set.id))?;
        let set_cs_state = multi_cs_logic.c_value();
        writeln!(file, "        .multi_rom_cs1_state = {},", set_cs_state)?;
        writeln!(file, "    }},")?;
    }

    writeln!(file, "}};")?;
    writeln!(file)?;

    // Generate ROM set data arrays
    let board = &config.board;
    for rom_set in rom_sets {
        // Determine image size based on number of ROMs in the set
        let image_size = if rom_set.roms.len() == 1 {
            match config.board.mcu_family() {
                McuFamily::Stm32f4 => 16384,
                McuFamily::Rp2350 => 65536,
            }
        } else {
            // Multi-ROM/banked sets: combined 64KB image
            65536
        };
        let ii = rom_set.id;

        writeln!(file, "// ROM set {} data", rom_set.id)?;
        writeln!(file, "__attribute__((section(\".rom_data\")))")?;
        writeln!(
            file,
            "static const uint8_t rom_set_{}_data[ROM_SET_{}_DATA_SIZE] = {{",
            ii, ii
        )?;

        fn format_binary_spaced(num: impl std::fmt::Binary, width: usize) -> String {
            let binary = format!("{:0width$b}", num, width = width);
            binary
                .chars()
                .collect::<Vec<_>>()
                .chunks(4)
                .map(|chunk| chunk.iter().collect::<String>())
                .collect::<Vec<_>>()
                .join(" ")
        }

        for address in 0..image_size {
            if address % 256 == 0 {
                // Comment address every 256 bytes
                if address > 0 {
                    writeln!(file)?;
                    writeln!(file)?;
                }

                // Output address in hex and binary
                writeln!(
                    file,
                    "    // Address 0x{:04x}, {}",
                    address,
                    format_binary_spaced(address, 16)
                )?;
                if rom_set.roms.len() > 1 {
                    writeln!(
                        file,
                        "    // CS1 = {}, X1 = {}, X2 = {}",
                        if (address & (1 << 10)) != 0 { 1 } else { 0 },
                        if (address & (1 << 14)) != 0 { 1 } else { 0 },
                        if (address & (1 << 15)) != 0 { 1 } else { 0 }
                    )?;
                }
            } else if address % 16 == 0 {
                // Otherwise, start a newline every 16 bytes
                writeln!(file)?;
            }

            if address % 16 == 0 {
                write!(file, "    ")?;
            }

            let byte = rom_set.get_byte(address, board);
            write!(file, "0x{:02x}, ", byte)?;
        }

        writeln!(file)?;
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    Ok(())
}

// Generate sdrr_config.h header file
fn generate_sdrr_config_header(filename: &Path, config: &Config) -> Result<()> {
    let mut file = create_file(&config.output_dir, filename, FileType::C)?;

    writeln!(file, "#ifndef SDRR_CONFIG_H")?;
    writeln!(file, "#define SDRR_CONFIG_H")?;
    writeln!(file)?;

    writeln!(
        file,
        "// Created within main.c but required by sdrr_config.c"
    )?;
    writeln!(file, "extern const char sdrr_build_date[];")?;
    writeln!(file)?;

    writeln!(file, "//")?;
    writeln!(file, "// Hardware configuration")?;
    writeln!(file, "//")?;

    // MCU variant
    writeln!(file)?;
    writeln!(file, "// MCU variant")?;
    writeln!(file, "{}", config.mcu_variant.define_var_fam())?;
    writeln!(file, "{}", config.mcu_variant.define_var_sub_fam())?;
    writeln!(file, "{}", config.mcu_variant.define_var_str())?;
    writeln!(
        file,
        "#define MCU_FLASH_SIZE     {}",
        config.mcu_variant.flash_storage_bytes()
    )?;
    writeln!(
        file,
        "#define MCU_FLASH_SIZE_KB  {}",
        config.mcu_variant.flash_storage_kb()
    )?;
    writeln!(
        file,
        "#define MCU_RAM_SIZE       {}",
        config.mcu_variant.ram_bytes()
    )?;
    writeln!(
        file,
        "#define MCU_RAM_SIZE_KB    {}",
        config.mcu_variant.ram_kb()
    )?;
    if let Some(ccm_ram_kb) = config.mcu_variant.ccm_ram_kb() {
        writeln!(file, "#define CCM_RAM_BASE 0x10000000")?;
        writeln!(file, "#define CCM_RAM_SIZE {}", ccm_ram_kb * 1024)?;
        writeln!(file, "#define CCM_RAM_SIZE_KB {}", ccm_ram_kb)?;
    }

    writeln!(file)?;
    if !config.bootloader {
        writeln!(
            file,
            "#define NO_BOOTLOADER 1  // Jumper based bootloader disabled"
        )?;
    } else {
        writeln!(
            file,
            "// #define NO_BOOTLOADER 0  // Jumper based bootloader enabled"
        )?;
    }
    writeln!(file, "// SDRR hardware revision")?;

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Clocking configuration")?;
    writeln!(file, "//")?;

    // Target frequency
    writeln!(file)?;
    writeln!(file, "// Target frequency")?;
    writeln!(file, "#define TARGET_FREQ_MHZ    {}", config.freq)?;

    // Oscillator config
    writeln!(file)?;
    writeln!(file, "// Oscillator configuration")?;
    if config.hse {
        writeln!(file, "// #define HSI 0")?;
        writeln!(file, "#define HSE 1     // External oscillator selected")?;
    } else {
        writeln!(file, "#define HSI 1     // Internal oscillator selected")?;
        writeln!(file, "// #define HSE 0")?;
    }

    // PLL configuration (F4 family only)
    writeln!(file)?;
    writeln!(file, "// PLL configuration")?;
    let pll = PllConfig::new(config.mcu_variant.processor());
    if let Some(pll_defines) = pll.generate_pll_defines(config.freq, config.overclock) {
        writeln!(file, "{}", pll_defines)?;
        if config.overclock {
            writeln!(file, "#define OVERCLOCK 1  // Overclocking enabled")?;
        } else {
            writeln!(file, "//#define OVERCLOCK 0  // Overclocking disabled")?;
        }
    } else {
        writeln!(file, "// PLL configuration not applicable for this variant")?;
    }

    // Count ROM access
    writeln!(file)?;
    writeln!(file, "// Count ROM access")?;
    if config.count_rom_access {
        writeln!(file, "#define COUNT_ROM_ACCESS 1")?;
    } else {
        writeln!(
            file,
            "// #define COUNT_ROM_ACCESS 0  // ROM access counting disabled"
        )?;
    }

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Debug and development configuration")?;
    writeln!(file, "//")?;

    // Preload ROM image to RAM
    writeln!(file)?;
    writeln!(file, "// Preload ROM image to RAM")?;
    if config.preload_to_ram {
        writeln!(file, "#define PRELOAD_TO_RAM 1")?;
    } else {
        writeln!(
            file,
            "// #define PRELOAD_TO_RAM 0  // Preloading to RAM disabled"
        )?;
    }

    // SWD
    writeln!(file)?;
    writeln!(file, "// SWD mode")?;
    if config.swd {
        writeln!(file, "#define SWD 1")?;
    } else {
        writeln!(file, "// #define SWD 0  // SWD mode disabled")?;
    }

    // MCO configuration
    writeln!(file)?;
    writeln!(file, "// MCO configuration")?;
    if config.mco {
        writeln!(file, "#define MCO  1")?;
        if config.mco2 {
            writeln!(file, "#define MCO2 1")?;
        } else {
            writeln!(file, "// #define MCO2 0  // MCO2 not used")?;
        }
    } else {
        writeln!(file, "// #define MCO  0  // MCO not used")?;
        writeln!(file, "// #define MCO2 0  // MCO2 not used")?;
    }

    // Boot logging
    writeln!(file)?;
    writeln!(file, "// Boot logging")?;
    if config.boot_logging {
        writeln!(file, "#define BOOT_LOGGING 1")?;
    } else {
        writeln!(file, "// #define BOOT_LOGGING 0  // Boot logging disabled")?;
    }

    // Main loop logging
    writeln!(file)?;
    writeln!(file, "// Main loop logging")?;
    if config.main_loop_logging {
        writeln!(file, "#define MAIN_LOOP_LOGGING 1")?;
    } else {
        writeln!(
            file,
            "// #define MAIN_LOOP_LOGGING 0  // Main loop logging disabled"
        )?;
    }

    // Main loop one-shot mode
    writeln!(file)?;
    writeln!(file, "// Main loop one-shot mode")?;
    if config.main_loop_one_shot {
        writeln!(file, "#define MAIN_LOOP_ONE_SHOT 1")?;
    } else {
        writeln!(
            file,
            "// #define MAIN_LOOP_ONE_SHOT 0  // Main loop one-shot mode disabled"
        )?;
    }

    // Debug logging
    writeln!(file)?;
    writeln!(file, "// Debug logging")?;
    if config.debug_logging {
        writeln!(file, "#define DEBUG_LOGGING 1")?;
    } else {
        writeln!(
            file,
            "// #define DEBUG_LOGGING 0  // Debug logging disabled"
        )?;
    }

    // Status LED
    writeln!(file)?;
    writeln!(file, "// Status LED")?;
    if config.status_led {
        writeln!(file, "#define STATUS_LED 1")?;
    } else {
        writeln!(file, "// #define STATUS_LED 0  // Status LED not used")?;
    }

    writeln!(file)?;
    writeln!(file, "#endif // SDRR_CONFIG_H")?;

    Ok(())
}

// Generate sdrr_config.c implementation file
fn generate_sdrr_config_implementation(filename: &Path, config: &Config) -> Result<()> {
    let mut file = create_file(&config.output_dir, filename, FileType::C)?;

    writeln!(file, "#include \"sdrr_config.h\"")?;
    writeln!(file, "#include \"config_base.h\"")?;
    writeln!(file, "#include \"roms.h\"")?;
    writeln!(file, "#include \"SEGGER_RTT.h\"")?;
    writeln!(file)?;

    writeln!(
        file,
        "// Linker variable containing location of metadata header"
    )?;
    writeln!(file, "extern char _metadata_start;")?;
    writeln!(file)?;

    let board = &config.board;

    // Pin definitions
    writeln!(file, "// Pin definitions")?;
    writeln!(file, "static const sdrr_pins_t sdrr_pins = {{")?;
    writeln!(file, "    .data_port = {},", board.port_data())?;
    writeln!(file, "    .addr_port = {},", board.port_addr())?;
    writeln!(file, "    .cs_port = {},", board.port_cs())?;
    writeln!(file, "    .sel_port = {},", board.port_sel())?;
    writeln!(file, "    .status_port = {},", board.port_status())?;
    writeln!(file, "    .rom_pins = {},", board.rom_pins())?;
    writeln!(file, "    .reserved1 = {{0, 0}},")?;

    let data_pins = board.data_pins();
    let data_pins_str = data_pins
        .iter()
        .map(|v| v.to_string())
        .collect::<Vec<_>>()
        .join(", ");
    writeln!(file, "    .data = {{ {} }},", data_pins_str)?;

    let mut addr_pins: Vec<_> = board.addr_pins().into();
    addr_pins.resize(16, 255);
    let addr_pins_str = addr_pins
        .iter()
        .map(|v| v.to_string())
        .collect::<Vec<_>>()
        .join(", ");
    writeln!(file, "    .addr = {{ {} }},", addr_pins_str)?;

    writeln!(file, "    .reserved2 = {{0, 0, 0, 0}},")?;
    writeln!(file, "    .cs1 = {},", board.pin_cs1(RomType::Rom2364))?;
    writeln!(file, "    .cs2 = {},", board.pin_cs2(RomType::Rom2332))?;
    writeln!(file, "    .cs3 = {},", board.pin_cs2(RomType::Rom2316))?; // This is correctly 2316's CS2
    writeln!(file, "    .reserved2a = {{255}},")?;
    writeln!(file, "    .reserved2b = {{255}},")?;
    writeln!(file, "    .reserved2c = {{255}},")?;
    writeln!(file, "    .x1 = {},", board.pin_x1())?;
    writeln!(file, "    .x2 = {},", board.pin_x2())?;
    writeln!(file, "    .ce = {},", board.pin_ce(RomType::Rom23128))?;
    writeln!(file, "    .oe = {},", board.pin_oe(RomType::Rom23128))?;
    writeln!(file, "    .x_jumper_pull = {},", board.x_jumper_pull())?;
    writeln!(file, "    .reserved3 = {{0, 0, 0, 0, 0}},")?;
    writeln!(
        file,
        "    .sel = {{ {}, {}, {}, {}, {}, {}, {} }},",
        board.pin_sel(0),
        board.pin_sel(1),
        board.pin_sel(2),
        board.pin_sel(3),
        board.pin_sel(4),
        board.pin_sel(5),
        board.pin_sel(6),
    )?;
    writeln!(file, "    .sel_jumper_pull = {},", board.sel_jumper_pull())?;
    writeln!(file, "    .status = {},", board.pin_status())?;
    writeln!(file, "    .reserved5 = {{0, 0, 0}},")?;

    writeln!(file, "}};")?;
    writeln!(file)?;

    // Extra info structure, introduced in v0.4.0
    writeln!(file, "// Extra info")?;
    writeln!(file, "static const sdrr_extra_info_t sdrr_extra_info = {{")?;
    writeln!(file, "    .rtt = &_SEGGER_RTT,")?;
    if board.has_usb() {
        writeln!(file, "    .usb_dfu = 1,")?;
        writeln!(file, "    .usb_port = {},", board.port_usb())?;
        writeln!(file, "    .vbus_pin = {},", board.usb_vbus_pin().expect("USB VBUS pin not defined"))?;
    } else {
        writeln!(file, "    .usb_dfu = 0,")?;
        writeln!(file, "    .usb_port = PORT_NONE,")?;
        writeln!(file, "    .vbus_pin = 255,")?;
    }
    writeln!(file, "    .reserved1 = {{0}},")?;
    writeln!(file, "    ._post = {{")?;
    for _ in 0..31 {
        writeln!(
            file,
            "        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,"
        )?;
    }
    writeln!(file, "    }},")?;
    writeln!(file, "}};")?;

    // Hardware revision string
    writeln!(
        file,
        "// Hardware revision string - {}",
        board.description()
    )?;
    writeln!(
        file,
        "static const char sdrr_hw_rev[] = \"{}\";",
        board.name()
    )?;

    // Main info structure
    writeln!(
        file,
        "// Main SDRR information structure, located at known point in flash"
    )?;
    writeln!(
        file,
        "__attribute__((section(\".sdrr_info\"))) const sdrr_info_t sdrr_info = {{"
    )?;

    // Magic bytes
    writeln!(file, "    .magic = {{'S', 'D', 'R', 'R'}},")?;

    // Version info - these would come from environment or build system
    writeln!(file, "    .major_version = SDRR_VERSION_MAJOR,")?;
    writeln!(file, "    .minor_version = SDRR_VERSION_MINOR,")?;
    writeln!(file, "    .patch_version = SDRR_VERSION_PATCH,")?;
    writeln!(file, "    .build_number = SDRR_BUILD_NUMBER,")?;

    // Build date pointer
    writeln!(file, "    .build_date = sdrr_build_date,")?;

    // Git commit - this would come from build system
    writeln!(file, "    .commit = SDRR_GIT_COMMIT,")?;

    // Hardware revision
    writeln!(file, "    .hw_rev = sdrr_hw_rev,")?;

    // MCU info
    writeln!(file, "    .mcu_line = {},", config.mcu_variant.line_enum())?;
    writeln!(
        file,
        "    .mcu_storage = {},",
        config.mcu_variant.storage_enum()
    )?;

    // Frequency and overclock
    writeln!(file, "    .freq = {},", config.freq)?;
    writeln!(
        file,
        "    .overclock = {},",
        if config.overclock { 1 } else { 0 }
    )?;

    // Feature flags
    writeln!(
        file,
        "    .swd_enabled = {},",
        if config.swd { 1 } else { 0 }
    )?;
    writeln!(
        file,
        "    .preload_image_to_ram = {},",
        if config.preload_to_ram { 1 } else { 0 }
    )?;
    writeln!(
        file,
        "    .bootloader_capable = {},",
        if config.bootloader { 1 } else { 0 }
    )?;
    writeln!(
        file,
        "    .status_led_enabled = {},",
        if config.status_led { 1 } else { 0 }
    )?;
    writeln!(
        file,
        "    .boot_logging_enabled = {},",
        if config.boot_logging { 1 } else { 0 }
    )?;
    writeln!(
        file,
        "    .mco_enabled = {},",
        if config.mco { 1 } else { 0 }
    )?;

    // ROM set info
    writeln!(file, "    .deprecated_rom_set_count = 0xFF,")?;
    writeln!(
        file,
        "    .count_rom_access = {},",
        if config.count_rom_access { 1 } else { 0 }
    )?;
    writeln!(file, "    .pad2 = {{0}},")?;
    writeln!(
        file,
        "    .metadata_header = (const struct onerom_metadata_header_t *)&_metadata_start,"
    )?;
    writeln!(file, "    .pins = &sdrr_pins,")?;

    // Boot configuration - reserved for future use, set to 0xff
    writeln!(file, "    .boot_config = {{0xff, 0xff, 0xff, 0xff}},")?;
    writeln!(file, "    .extra = &sdrr_extra_info,")?;

    writeln!(file, "}};")?;

    Ok(())
}

fn generate_makefile_fragment(filename: &Path, config: &Config) -> Result<()> {
    let mut file = create_file(&config.output_dir, filename, FileType::Makefile)?;

    // MCU variant
    writeln!(file, "# MCU variant")?;
    writeln!(file, "VARIANT={}", config.mcu_variant.makefile_var())?;

    // probe-rs chip-id
    writeln!(file)?;
    writeln!(file, "# probe-rs Chip ID")?;
    writeln!(file, "PROBE_RS_CHIP_ID={}", config.mcu_variant.chip_id())?;

    // Device flash base
    writeln!(file)?;
    writeln!(file, "# Device flash base")?;
    writeln!(
        file,
        "FLASH_BASE={:#010X}",
        config.board.mcu_family().get_flash_base()
    )?;

    Ok(())
}

fn generate_linker_script(filename: &Path, config: &Config) -> Result<()> {
    let mut file = create_file(&config.output_dir, filename, FileType::Linker)?;

    writeln!(file, "INCLUDE \"common_vars.ld\"")?;
    writeln!(file)?;
    writeln!(file, "MEMORY")?;
    writeln!(file, "{{")?;
    match config.mcu_variant.family() {
        McuFamily::Rp2350 => {
            writeln!(
                file,
                "    FLASH (rx) : ORIGIN = 0x10000000, LENGTH = {}K",
                config.mcu_variant.flash_storage_kb()
            )?;
        }
        McuFamily::Stm32f4 => {
            writeln!(
                file,
                "    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = {}K",
                config.mcu_variant.flash_storage_kb()
            )?;
        }
    }
    writeln!(
        file,
        "    RAM (xrw)  : ORIGIN = 0x20000000, LENGTH = {}K",
        config.mcu_variant.ram_kb()
    )?;
    if let Some(ccm_ram_kb) = config.mcu_variant.ccm_ram_kb() {
        writeln!(
            file,
            "    CCMRAM (rw): ORIGIN = 0x10000000, LENGTH = {}K",
            ccm_ram_kb
        )?;
    }
    writeln!(file, "}}")?;
    writeln!(file)?;

    match config.mcu_variant.family() {
        McuFamily::Rp2350 => {
            writeln!(file, "_Ram_Rom_Image_Start = ORIGIN(RAM) + 0x10000;")?;
        }
        McuFamily::Stm32f4 => {
            writeln!(
                file,
                "_Ram_Rom_Image_Start = ORIGIN(RAM) + _Sdrr_Runtime_Info_Size;"
            )?;
        }
    }
    if config.mcu_variant.ram_kb() > 72 {
        writeln!(file, "_Ram_Rom_Image_Size = 0x10000;  /* 64 KB */")?;
    } else {
        writeln!(file, "_Ram_Rom_Image_Size = 0x04000;  /* 16 KB */")?;
    }
    writeln!(file)?;
    writeln!(file, "INCLUDE \"common.ld\"")?;

    Ok(())
}

fn generate_platform_ld_script(filename: &Path, config: &Config) -> Result<()> {
    let mut file = create_file(&config.output_dir, filename, FileType::Linker)?;
    match config.mcu_variant.family() {
        McuFamily::Rp2350 => {
            writeln!(file, "/* RP2350 specific linker script */")?;
            writeln!(file, ".rp2350_block :")?;
            writeln!(file, "{{")?;
            writeln!(file, "    . = ALIGN(4);")?;
            writeln!(file, "    KEEP(*(.rp2350_block))")?;
            writeln!(file, "    . = ALIGN(4);")?;
            writeln!(file, "}} >FLASH")?;
        }
        McuFamily::Stm32f4 => {
            writeln!(file, "/* STM32F4 specific linker script */")?;
            writeln!(file)?;
            writeln!(file, "/* Intentionally empty */")?;
        }
    }

    Ok(())
}
