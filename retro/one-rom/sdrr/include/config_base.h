// Contains configuration definitions and types which are used by the
// configuration generated by `sdrr-gen`. 

// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

#ifndef CONFIG_BASE_H
#define CONFIG_BASE_H

#include <stdint.h>

typedef enum {
    F401DE = 0x0000,  // 96 KB RAM
    F405 = 0x0001,
    F411 = 0x0002,
    F446 = 0x0003,
    F401BC = 0x0004,  // Only 64KB RAM
    RP2350_LINE = 0x0005,
    MCU_LINE_FORCE_UINT16 = 0xFFFF,
} mcu_line_t;

typedef enum {
    STORAGE_8 = 0x00,
    STORAGE_B = 0x01,
    STORAGE_C = 0x02,
    STORAGE_D = 0x03,
    STORAGE_E = 0x04,
    STORAGE_F = 0x05,
    STORAGE_G = 0x06,
    STORAGE_2MB = 0x07,
    MCU_STORAGE_FORFCE_UINT16 = 0xFFFF,
} mcu_storage_t;

// Only ports A-D are exposed on the 64-pin STM32F4s.
// RP2350 has port (bank) 0.
typedef enum {
    PORT_NONE = 0x00,
    PORT_A    = 0x01,
    PORT_B    = 0x02,
    PORT_C    = 0x03,
    PORT_D    = 0x04,
    PORT_0    = 0x05,  // RP2350
} sdrr_mcu_port_t;

// Pin allocations
//
// All pin numbers are physical pins - allocated from the configured STM32F4
// port.  Valid numbers are 0-15 on the STM32, 0-29 on the RP2350.
// 255 indicates a particular pin is present.
// The index into the array is ROM Address x or Data x number.
#define INVALID_PIN  255
typedef struct {
    // SDRR MCU pin port locations
    // Offset: 0
    // 8 x 1 byte = 8 bytes
    sdrr_mcu_port_t data_port;  // Data lines
    sdrr_mcu_port_t addr_port;  // Address lines
    sdrr_mcu_port_t cs_port;    // Chip select/enable lines
    sdrr_mcu_port_t sel_port;   // Image select jumpers
    sdrr_mcu_port_t status_port; // Status LED
    uint8_t rom_pins;           // Number of pins this ROM is emulating 
    uint8_t reserved1[2];

    // 8 data lines
    // Offset: 8
    // 8 bytes
    uint8_t data[8];

    // Up to 16 address lines.  0xFF indicates unused line.
    // Offset: 16
    // 20 x 1 byte = 20 bytes
    uint8_t addr[16];
    uint8_t reserved2[4];

    // Chip select lines for supported variants
    //
    // x_jumper_pull is the direction of pull from the X1/X2 jumper on the
    // board.  It is 1 if that jumper closing pulls it high, and 0 if it pulls
    // it low.
    //
    // Offset: 36
    // 16 x 1 byte = 16 bytes
    uint8_t cs1;
    uint8_t cs2;
    // 3rd CS line, only used on 2316 and 23128, actually 2316's CS2, as 2316's CS3 is 2332's CS2
    uint8_t cs3;
    uint8_t reserved2a[1];
    uint8_t reserved2b[1];
    uint8_t reserved2c[1];
    uint8_t x1;
    uint8_t x2;
    uint8_t ce;
    uint8_t oe;
    uint8_t x_jumper_pull;
    uint8_t reserved3[5];

    // Image select lines
    //
    // Sel jumper pull is the direction of pull-up or pull-down when closing
    // the jumper on this board type.  If 1, closing the jumper pulls it up.
    // This is used by One ROM to decide what type of its own pulls to apply
    // (the opposite).  Closing is always interpreted as a 1 by One ROM.
    //
    // Unused image select pins are set to 255.
    //
    // The order of pins in this array is significant - [0] is bit 0 of the
    // interpreted value, [1] bit 1, etc.  If a pin is missing (255) mid
    // array, the _next_ entry will be missing bit.
    //
    // Offset: 52
    // 8 bytes
#define MAX_IMG_SEL_PINS 7
    uint8_t sel[MAX_IMG_SEL_PINS];
    uint8_t sel_jumper_pull;

    // Status LED line
    // Offset: 60
    // 4x1 byte = 4 byte
    uint8_t status;
    uint8_t reserved5[3];

    // Length: 64
} sdrr_pins_t;

// Forward declarations
struct onerom_metadata_header_t;

// Extra information stored in flash
typedef struct {
    // Pointer to RTT control block
    const void *rtt;

    // Whether USB DFU is supported
    uint8_t usb_dfu;
    // Which GPIO port USB pins are located on
    sdrr_mcu_port_t usb_port;
    // Pin number for VBUS detection
    uint8_t vbus_pin;
    uint8_t reserved1[1];

    // Padding to make 256 bytes long
    uint8_t _post[248];
} sdrr_extra_info_t;

// Main SDRR information data structure
typedef struct {
    // Magic bytes to identify the firmware and structure
    // Offset: 0
    // 4 bytes
    const char magic[4];  // Magic bytes = "SDRR"

    // Firmware version information
    // Offset: 4
    // 4 x 2 bytes = 8 bytes
    const uint16_t major_version;
    const uint16_t minor_version;
    const uint16_t patch_version;
    const uint16_t build_number;

    // Pointer to build date/time string
    // Offset: 12
    // 4 bytes
    const char* build_date;

    // Git commit hash, NULL terminated
    // Offset: 16
    // 8 bytes
    char commit[8];

    // Hardware revision - pointer to string
    // Offset: 24
    // 4 bytes
    const char* hw_rev;

    // MCU product line
    // Offset: 28
    // 2 x 2 bytes = 4 bytes
    const mcu_line_t mcu_line;
    const mcu_storage_t mcu_storage;

    // Target frequency in MHz
    // Offset: 32
    // 2 + 1 bytes = 3 bytes
    const uint16_t freq;
    const uint8_t overclock;

    // Enable SWD support
    // Offset: 35
    // 1 byte
    const uint8_t swd_enabled;

    // Various debug options
    // Offset: 36
    // 5 x 1 bytes = 5 bytes
    const uint8_t preload_image_to_ram;
    const uint8_t bootloader_capable;
    const uint8_t status_led_enabled;
    const uint8_t boot_logging_enabled;
    const uint8_t mco_enabled;

    // Padding.
    //
    // In pre-v0.5.0 firmware, this was used as the number of ROM sets in the
    // firmware.  We now indicate that within the metadata header.
    // Offset: 41
    // 1 byte
    const uint8_t deprecated_rom_set_count;

    // Whether access count is enabled
    // Offset: 42
    // 1 byte
    const uint8_t count_rom_access;

    // Reserved for future use
    const uint8_t pad2[1];
    
    // Pointer to metadata.
    //
    // In pre-v0.5.0 firmware versions this was used as a pointer to rom_sets.
    // We have now added an addition structure and redirection to rom_sets,
    // pointing to them within the metadata header.  
    //
    // Offset: 44
    // 4 bytes
    const struct onerom_metadata_header_t *metadata_header;

    // Pin allocation structure
    // Offset: 48
    // 4 bytes
    const sdrr_pins_t *pins;

    // Boot configuration.  This is for future use.  For example, an external
    // programmer may change this value, and the SDRR firmware check it on
    // boot, and decide to pre-select an image based on it, rather than the
    // sel jumpers.
    // 
    // As such this is reserved and must be set to 0xff.
    //
    // Offset: 52
    // 4 bytes
    const uint8_t boot_config[4];

    // 56 bytes to here

    // v0.4.0 beyond here
    
    // Pointer to RTT control block
    const sdrr_extra_info_t *extra;

    // 4 further bytes
    uint8_t _post[4];

    // Length: 64
} sdrr_info_t;

// ROM image sizes by type (F1 family)
#define ROM_IMAGE_SIZE_2316  2048
#define ROM_IMAGE_SIZE_2332  4096
#define ROM_IMAGE_SIZE_2364  8192

// Maximum ROM image size (F4 family uses a single size for all ROM types)
#define ROM_IMAGE_SIZE_STM32F4  16384
#define ROM_IMAGE_SIZE_RP235X   65536

// ROM image size for sets of more than 1 ROM image
#define ROM_SET_IMAGE_SIZE  65536

// ROM type enumeration
typedef enum {
    ROM_TYPE_2316,
    ROM_TYPE_2332,
    ROM_TYPE_2364,
    ROM_TYPE_23128,
    ROM_TYPE_23256,
    ROM_TYPE_23512,
    ROM_TYPE_2704,
    ROM_TYPE_2708,
    ROM_TYPE_2716,
    ROM_TYPE_2732,
    ROM_TYPE_2764,
    ROM_TYPE_27128,
    ROM_TYPE_27256,
    ROM_TYPE_27512,
} sdrr_rom_type_t;

// CS state enumeration
typedef enum {
    CS_ACTIVE_LOW,
    CS_ACTIVE_HIGH,
    CS_NOT_USED,
} sdrr_cs_state_t;

// ROM serving algorithm
typedef enum {
    // Original ROM serving algorithm - tests the chip select state(s) twice
    // as often as it loads the ROM data given the address lines state.  This
    // is the default algorithm, and is used for all single ROM sets.
    SERVE_TWO_CS_ONE_ADDR,

    // Serves the byte from RAM only once chip select line(s) active.
    // Very similar to SERVE_ADDR_ON_ANY_CS - but this only matches on all
    // of the required CS lines, that matches on any, so is suitable for
    // multiple ROM sets.
    SERVE_ADDR_ON_CS,

    // Serves the byte from RAM once any of the chip select lines are active.
    // This is used for sets with multiple ROM images, where we don't know the
    // full address (i.e. the image to lookup from) until any of the chip
    // select lines are active.  This is the default algorithm for sets with
    // multiple ROM images on hardware revision F.
    SERVE_ADDR_ON_ANY_CS,
} sdrr_serve_t;
#define SERVE_DEFAULT_1_ROM  SERVE_ADDR_ON_CS

// ROM information structure
typedef struct {
    const sdrr_rom_type_t rom_type;     // ROM type
    const sdrr_cs_state_t cs1_state;    // CS1 state
    const sdrr_cs_state_t cs2_state;    // CS2 state
    const sdrr_cs_state_t cs3_state;    // CS3 state
    const char* filename;               // Source filename (May be NULL)
} sdrr_rom_info_t;

// ROM set information structure
//
// SDRR can serve sets of ROM images, which are addressed using the entirety
// of the STM32F4 port C.  This is done in order to emulate multuple ROMs
// simultaneously, with  the additional ROM select lines attached to SDRR via
// X1 and X2.
//
// If the multiple ROM image support is not used, there is be a 1:1 mapping
// between set and image - i.e. `rom_count` is be 1.
typedef struct sdrr_rom_set_t {
    // Pointer to the data for the ROM image(s) in this set.  Copied to RAM at
    // startup.
    const uint8_t* data;

    // Size of the data for the ROM image(s) in this set.  Used to copy the
    // ROM data to RAM at startup.  This is either:
    // - ROM_IMAGE_SIZE for a single ROM image
    // - ROM_SET_IMAGE_SIZE for a set of multiple ROM images
    const uint32_t size;

    // Pointer to array of pointers to ROMs in this set.  Note it needs to be
    // a pointer to const pointer to const data, otherwise the linker will
    // decide that the sdrr_rom_info_t structs need to be relocated to RAM
    // on startup, which is unnecessary. 
    const sdrr_rom_info_t* const * roms;

    // The number of unique ROM images in this set.  Used to index the above
    // array.
    const uint8_t rom_count;

    // Which ROM serving algorithm to use for this set.
    const sdrr_serve_t serve;         // ROM serving algorithm

    // CS1 state (active high/low) when using multiple ROM images in this set
    const sdrr_cs_state_t multi_rom_cs1_state;  // CS1 state
} sdrr_rom_set_t;

// SDRR Runtime Information Structure
//
// Contains information about the SDRR runtime environment.
typedef struct sdrr_runtime_info_t {
    // Magic bytes to identify the firmware and structure
    // Offset: 0
    // 4 bytes
    char magic[4];  // Magic bytes = "SDRR"

    // Size of this structure in bytes
    // Offset: 4
    // 1 byte
    uint8_t runtime_info_size;

    // Image select jumper state at boot.
    // Initialized to 0xFF.
    // Offset: 5
    // 1 byte
    uint8_t  image_sel;

    // Index of the currently selected ROM set.  This is chosen at boot via
    // the image select jumpers.
    // Initialized to 0xFF.
    // Offset: 6
    // 1 byte
    uint8_t rom_set_index;

    // Whether the ROM access counting feature is enabled.
    // Initialized to 0x00.
    // Offset: 7
    // 1 byte
    uint8_t count_rom_access;

    // Counter for the number times the CS lines have transitioned from
    // inactive to active.  This is only updated if COUNT_ROM_ACCESS is
    // defined in the configuration.  This field is unused (but present) if
    // COUNT_ROM_ACCESS is not defined.
    // Initialized to 0xFFFFFFFF.  Only set to 0x00000000 if COUNT_ROM_ACCESS
    // is defined, when the ROM starts serving.
    // Offset: 8
    // 4 bytes
    uint32_t access_count;

    // Pointer to the ROM table SDRR uses to serve the ROM data this run
    // Initialized to null.
    // Offset: 12
    // 4 bytes
    void *rom_table;

    // Length of the ROM table SDRR is serving in bytes.
    // Initialized to 0.
    // Offset: 16
    // 4 bytes
    uint32_t rom_table_size;

    // Whether to enter DFU mode - STM32 only.
    //
    // 0x21554644 ("DFU!" little endian) enters bootloader
#define ENTER_BOOTLOADER_MAGIC 0x21554644
    uint32_t bootloader_entry;
} sdrr_runtime_info_t;

// One ROM Metadata Header
//
// Placed at the start of the metadata flash area to indicate:
// - metadata version
// - location of the actual metadata
typedef struct onerom_metadata_header_t {
    // Magic bytes to identify the metadata header
    //
    // Offset: 0
    const char magic[16];  // "ONEROM_METADATA\0"

    // Metadata version
    //
    // Offset: 16
    const uint32_t version; // Metadata version - currently 1

    // Number of installed ROM sets
    // 
    // Offset: 20
    const uint8_t rom_set_count;
    const uint8_t pad1[3];

    // Pointer to array of ROM sets (also in metadata section)
    //
    // Offset: 24
    const sdrr_rom_set_t *rom_sets;

    // Reserved for future expansion.
    //
    // Offset: 28
    const uint8_t reserved[228];

} onerom_metadata_header_t;

#endif // CONFIG_BASE_H