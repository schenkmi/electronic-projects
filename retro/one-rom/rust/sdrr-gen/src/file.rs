// Copyright (C) 2025 Piers Finlayson <piers@piers.rocks>
//
// MIT License

//! sdrr-gen - File handling logic for the SDRR generator.
//!
//! Primarily handles sourcing ROM image files from local paths or URLs,
//! including downloading and caching them as needed.

use anyhow::{Context, Result, anyhow};
use bytes::Bytes;
use std::collections::HashMap;
use std::fmt;
use std::fs;
use std::fs::{File, OpenOptions, copy, create_dir_all, remove_dir_all};
use std::io::{Cursor, Read, Write};
use std::path::{Path, PathBuf};
use std::sync::LazyLock;
use strum::EnumIter;
use urlencoding::decode;
use zip::ZipArchive;

use onerom_gen::image::Rom;

use crate::config::Config;

// Files generated by generator.rs
const ROMS_C_FILE: &str = "roms.c";
const ROMS_H_FILE: &str = "roms.h";
const SDRR_CONFIG_H_FILE: &str = "sdrr_config.h";
const SDRR_CONFIG_C_FILE: &str = "sdrr_config.c";
const GEN_MK_FILE: &str = "generated.mk";
const LINKER_LD_FILE: &str = "linker.ld";
const PLATFORM_BOOT_BLOCK_LD_FILE: &str = "platform_boot_block.ld";

// Directory for ROM images
const IMAGE_DIR: &str = "images";

// Filename containing names of all ROM images
const IMAGE_LIST_FILE: &str = "image_list.txt";

#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq, EnumIter)]
pub enum OutType {
    RomsC,
    RomsH,
    SdrrConfigH,
    SdrrConfigC,
    GenMk,
    LinkerLd,
    PlatformBootBlockLd,
}

static OUT_FILES: LazyLock<HashMap<OutType, String>> = LazyLock::new(|| {
    let mut map = HashMap::new();
    map.insert(OutType::RomsC, ROMS_C_FILE.to_string());
    map.insert(OutType::RomsH, ROMS_H_FILE.to_string());
    map.insert(OutType::SdrrConfigH, SDRR_CONFIG_H_FILE.to_string());
    map.insert(OutType::SdrrConfigC, SDRR_CONFIG_C_FILE.to_string());
    map.insert(OutType::GenMk, GEN_MK_FILE.to_string());
    map.insert(OutType::LinkerLd, LINKER_LD_FILE.to_string());
    map.insert(
        OutType::PlatformBootBlockLd,
        PLATFORM_BOOT_BLOCK_LD_FILE.to_string(),
    );
    map
});

// Return the output filename for a given output type
pub fn out_filename(out_type: OutType) -> PathBuf {
    PathBuf::from(
        OUT_FILES
            .get(&out_type)
            .cloned()
            .expect("Internal error - unknown output file type"),
    )
}

// Return an iterator over the output filenames
fn out_filenames_iter() -> impl Iterator<Item = String> {
    OUT_FILES.values().cloned()
}

// Return the directory where generated files are stored
fn image_dir(output_dir: &Path) -> PathBuf {
    output_dir.join(IMAGE_DIR)
}

pub fn image_list_file(output_dir: &Path) -> PathBuf {
    image_dir(output_dir).join(IMAGE_LIST_FILE)
}

/// Check if the output directory is valid and does not contain existing
/// files that would be overwritten.
///
/// Returns OK(PathBuf) containing the output directory path, or
/// Err(String) with an error message.
pub fn check_output_dir(out_dir: &Path, overwrite: bool) -> Result<(), String> {
    let image_dir = image_dir(out_dir);

    if !overwrite && out_dir.exists() {
        for file_name in out_filenames_iter() {
            let file_path = out_dir.join(&file_name);
            if file_path.exists() {
                return Err(format!(
                    "Output directory already exists and contains '{}'. Use --overwrite to replace it.",
                    file_name
                ));
            }
        }

        for dir_name in &[out_dir, &image_dir] {
            let dir_path = out_dir.join(dir_name);
            if dir_path.exists() {
                return Err(format!(
                    "Output directory {}/{} already exists. Use --overwrite to potentially overwrite files in it.",
                    out_dir.display(),
                    dir_name.display(),
                ));
            }
        }
    }

    clean_image_dir(out_dir)
}

fn clean_image_dir(output_dir: &Path) -> Result<(), String> {
    // Delete any existing image directory
    let image_dir = image_dir(output_dir);
    remove_dir_all(&image_dir)
        .or_else(|_| fs::create_dir_all(&image_dir))
        .map_err(|e| format!("Failed to remove existing image directory: {}", e))?;

    create_dir_all(&image_dir).map_err(|e| format!("Failed to create image directory: {}", e))?;

    // Create the image list file
    File::create(image_list_file(output_dir))
        .map_err(|e| format!("Failed to create image list file: {}", e))?
        .write_all("List of ROM image files used to build this ROM:\n\n".as_bytes())
        .map_err(|e| format!("Failed to write to image list file: {}", e))
}

fn update_image_list(rom_num: usize, src: &FileSource, out_dir: &Path) -> Result<(), String> {
    let image_list_path = image_list_file(out_dir);
    let mut file = OpenOptions::new()
        .append(true)
        .open(&image_list_path)
        .map_err(|e| format!("Failed to open image list file: {}", e))?;

    writeln!(file, "ROM #{rom_num}: {}.rom - {}", rom_num, src)
        .map_err(|e| format!("Failed to write to image list file: {}", e))?;

    Ok(())
}

/// Sources a ROM image file, either from the local file system, a URL, or, if
/// in a zip archive, extracts it from there.
pub fn source_image_file(
    rom_num: usize,
    source: &FileSource,
    out_dir: &Path,
) -> Result<PathBuf, String> {
    // Create filename for this ROM
    let image_dir = image_dir(out_dir);
    let out_filename = PathBuf::from(format!("{rom_num}.rom"));
    let out_file = image_dir.join(out_filename);

    // Get the file and put in the image directory
    match &source {
        FileSource::Local(path) => copy_local_file(path, &out_file)?,
        FileSource::Url(url) => download_url(&out_file, url)?,
        FileSource::UrlZip(url, extract_file) => {
            download_and_extract_zip(&out_file, url, extract_file)?
        }
    };

    update_image_list(rom_num, source, out_dir)
        .map_err(|e| format!("Failed to update image list: {}", e))?;

    Ok(out_file)
}

// Load the ROM files based on the configuration
pub fn load_rom_files(config: &Config) -> Result<Vec<Rom>> {
    let mut roms = Vec::new();
    for (ii, rom_config) in config.roms.iter().enumerate() {
        // Read in the original ROM file
        let file = rom_config.file.clone();
        let src = fs::read(file.clone())
            .with_context(|| format!("Failed to read ROM file: {}", file.display()))?;

        // Create a Vec large enough for the expected ROM size
        let rom_size = rom_config.rom_type.size_bytes();
        let image = vec![0xFF_u8; rom_size];

        // Process the ROM image data
        let rom = Rom::from_raw_rom_image(
            ii,
            rom_config
                .original_source
                .clone()
                .split('/')
                .next_back()
                .unwrap_or("unknown")
                .to_string(),
            None,
            &src,
            image,
            &rom_config.rom_type,
            rom_config.cs_config.clone(),
            &rom_config.size_handling,
            None
        )
        .map_err(|e| anyhow!("Error processing ROM file {}: {e:?}", file.display()))?;

        roms.push(rom);
    }
    Ok(roms)
}

fn copy_local_file(src: &Path, dest: &Path) -> Result<(), String> {
    println!("Copying {} to {}", src.display(), dest.display());

    // Copy it to the image directory
    copy(src, dest).map_err(|e| format!("Failed to copy file: {e}"))?;

    // Check it got there
    if dest.exists() {
        Ok(())
    } else {
        Err(format!(
            "Failed to copy file {} to cache directory {}",
            src.display(),
            dest.display()
        ))
    }
}

fn download_file(url: &str) -> Result<Bytes, String> {
    // For SourceForge, use wget/curl since their bot detection breaks reqwest
    if url.contains("sourceforge.net") {
        return download_with_wget(url);
    }

    // Original reqwest logic for other URLs
    let client = reqwest::blocking::Client::builder()
        .user_agent("Wget/1.21.3")
        .cookie_store(true)
        .redirect(reqwest::redirect::Policy::limited(10))
        .build()
        .map_err(|e| format!("Failed to build HTTP client: {e}"))?;

    let response = client
        .get(url)
        .header("Accept", "*/*")
        .header("Accept-Encoding", "identity")
        .header("Connection", "Keep-Alive")
        .send()
        .map_err(|e| format!("Failed to download {url}: {e}"))?;

    response
        .bytes()
        .map_err(|e| format!("Failed to read download {url}: {e}"))
}

fn download_with_wget(url: &str) -> Result<Bytes, String> {
    println!("Falling back to wget");
    let output = std::process::Command::new("wget")
        .arg("-O")
        .arg("-")
        .arg("-q")
        .arg(url)
        .output()
        .map_err(|e| format!("Failed to run wget: {e}"))?;

    if !output.status.success() {
        return Err(format!("wget failed with status: {}", output.status));
    }

    Ok(Bytes::from(output.stdout))
}

fn download_url(dest_file: &Path, url: &str) -> Result<(), String> {
    println!("Downloading {url} to {}", dest_file.display());

    let bytes = download_file(url)?;

    let mut file =
        File::create(dest_file).map_err(|e| format!("Failed to create download file: {e}"))?;
    file.write_all(&bytes)
        .map_err(|e| format!("Failed to write download file: {}", e))?;

    Ok(())
}

fn download_and_extract_zip(dest_file: &Path, url: &str, extract_file: &str) -> Result<(), String> {
    // URL decode the extract filename to handle spaces and special characters
    let decoded_extract_file = decode(extract_file)
        .map_err(|e| format!("Failed to URL decode extract filename '{extract_file}': {e}"))?;

    println!(
        "Downloading and extracting {decoded_extract_file} from {url} to {}",
        dest_file.display()
    );

    let bytes = download_file(url)?;

    let cursor = Cursor::new(bytes);
    let mut archive =
        ZipArchive::new(cursor).map_err(|e| format!("Failed to open zip archive: {}", e))?;

    // First, collect all filenames and check if our target exists
    let mut file_names = Vec::new();
    let mut target_exists = false;

    // Iterate through the archive to find the target file
    for i in 0..archive.len() {
        if let Ok(f) = archive.by_index(i) {
            let name = f.name().to_string();
            if name == decoded_extract_file {
                target_exists = true;
            }
            file_names.push(name);
        }
    }

    // Couldn't find it
    if !target_exists {
        println!("Failed to find '{decoded_extract_file}' in zip. Archive contents:",);
        for name in &file_names {
            println!("  '{}'", name);
        }
        return Err(format!("Failed to find {decoded_extract_file} in zip"));
    }

    // Now we know the file exists, extract it
    let mut file = archive
        .by_name(&decoded_extract_file)
        .map_err(|e| format!("Failed to extract {decoded_extract_file}: {e}"))?;

    let mut contents = Vec::new();
    file.read_to_end(&mut contents)
        .map_err(|e| format!("Failed to read {extract_file} from zip: {e}"))?;

    // Save it off in the destination dir
    let mut file =
        File::create(dest_file).map_err(|e| format!("Failed to create extracted file: {e}"))?;
    file.write_all(&contents)
        .map_err(|e| format!("Failed to write extracted file: {e}"))?;

    Ok(())
}

pub enum FileSource {
    Local(PathBuf),
    Url(String),
    UrlZip(String, String), // URL and file to extract from the zip
}

impl fmt::Display for FileSource {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FileSource::Local(path) => write!(f, "{}", path.to_str().unwrap_or("Internal error")),
            FileSource::Url(url) => write!(f, "{}", url),
            FileSource::UrlZip(url, extract) => write!(f, "{extract} from {url}"),
        }
    }
}
